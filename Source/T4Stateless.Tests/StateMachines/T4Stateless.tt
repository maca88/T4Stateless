<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="EnvDTE"#>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.ComponentModel" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Linq.Expressions" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#
    var manager = Manager.Create(Host, GenerationEnvironment);
    manager.StartHeader(); 
#>
//----------------------
// <auto-generated>
//	Generated by T4StateMachine.
// </auto-generated>
//----------------------
// ReSharper disable All
using System;
using System.Collections.Generic;
using Stateless;
<#
    manager.EndBlock(); 
    var dir = Path.GetDirectoryName(Host.TemplateFile);
    var xmlPaths = Directory.GetFiles(dir, "*.xml");

    var xmlvalidator = new XmlValidator();
    foreach (var xmlPath in xmlPaths)
    {
        var xml = File.ReadAllText(xmlPath);
        xmlvalidator.Validate(xml, xmlPath);
        var entry = Entry.Deserialize(xml);
        manager.StartNewFile(string.Format("{0}.generated.cs", entry.name));
        //var states = new HashSet<string>(entry.GetAllStates());
        var stateType = entry.settings.statetype ?? "string";
        var events = new HashSet<string>(entry.GetAllEvents());
        var transitionGroups = entry.GetTransitionGroups().ToList();
        Func<string, string> formatConditionFn = (s) =>
        {
            return s.Replace($"{entry.settings.itemfieldname}.", "");

        };
        // Validation - an event must have always the same parameter type (this is a limitaion of stateless library)
        var invalidEvents = transitionGroups.GroupBy(o => o.Event)
            .Where(o => o.GroupBy(t => t.ParameterType).Count() > 1)
            .Select(o => $"Event: {o.Key} has multiple parameter types: {string.Join(",", o.GroupBy(t => t.ParameterType).Select(t => string.IsNullOrEmpty(t.Key) ? "None" : t.Key ).ToList())}")
            .ToList();
        if (invalidEvents.Any())
        {
            throw new NotSupportedException($"Events that have multiple parameter types are not supported:{Environment.NewLine}{string.Join(Environment.NewLine, invalidEvents)}");
        }
#>

namespace <#=entry.@namespace#>
{
<#    
        foreach (var u in entry.settings.usings)
        {
#>
    using <#=u#>;
<#
        }
#>

    public enum <#=entry.name#>Event
    {
<#
        foreach (var e in events)
        {
#>
        <#=e#>,
<#
        }
#>
    }

    public abstract class <#=entry.name#>FireBaseEvent<#=(string.IsNullOrEmpty(entry.settings.fireeventbasetype) ? "" : " : " + entry.settings.fireeventbasetype)#>
    {
        protected <#=entry.name#>FireBaseEvent(<#=entry.name#> item, <#=entry.name#>Event evt, bool isReentry)
        {
            <#=entry.name#> = item;
            Event = evt;
            IsReentry = isReentry;
        }

        public <#=entry.name#> <#=entry.name#> { get; }

        public <#=entry.name#>Event Event { get; }

        public bool IsReentry { get; }
    }
<#
        foreach (var g in entry.GetTransitionGroups().GroupBy(o => new {o.Event, o.ParameterType, o.Internal}))
        {
            if (g.Key.Internal)
            {
#>
    public class <#=entry.name#>Fire<#=g.Key.Event#>ReentryEvent : <#=entry.name#>FireBaseEvent
    {
        public <#=entry.name#>Fire<#=g.Key.Event#>ReentryEvent(<#=stateType#> state, <#=entry.name#> item<#=(string.IsNullOrEmpty(g.Key.ParameterType) ? "" : $", {g.Key.ParameterType} parameter")#>) : base(item, <#=entry.name#>Event.<#=g.Key.Event#>, true)
        {
            State = state;<#=(string.IsNullOrEmpty(g.Key.ParameterType) ? "" : "\r\n            Parameter = parameter;")#>
        }
        
        public <#=stateType#> State { get; }<#=(string.IsNullOrEmpty(g.Key.ParameterType) ? "" : $"\r\n\r\n        public {g.Key.ParameterType} Parameter {{ get; }}")#>
    }

<#
            }
            else
            {
#>
    public class <#=entry.name#>Fire<#=g.Key.Event#>Event : <#=entry.name#>FireBaseEvent
    {
        public <#=entry.name#>Fire<#=g.Key.Event#>Event(<#=stateType#> oldState, <#=stateType#> newState, <#=entry.name#> item<#=(string.IsNullOrEmpty(g.Key.ParameterType) ? "" : $", {g.Key.ParameterType} parameter")#>) : base(item, <#=entry.name#>Event.<#=g.Key.Event#>, false)
        {
            OldState = oldState;
            NewState = newState;<#=(string.IsNullOrEmpty(g.Key.ParameterType) ? "" : "\r\n            Parameter = parameter;")#>
        }
        
        public <#=stateType#> OldState { get; }

        public <#=stateType#> NewState { get; }<#=(string.IsNullOrEmpty(g.Key.ParameterType) ? "" : $"\r\n\r\n        public {g.Key.ParameterType} Parameter {{ get; }}")#>
    }

<#
            }
        }
#>

    public interface I<#=entry.name#>StateMachineProvider
    {
        <#=entry.name#>StateMachine Create(<#=entry.name#> item);
    }

    public partial class <#=entry.name#>StateMachine
    {
        private readonly StateMachine<<#=stateType#>, <#=entry.name#>Event> _sm;
        private readonly <#=entry.name#> <#=entry.settings.itemfieldname#>;
        private readonly Action<<#=entry.name#>FireBaseEvent> _handleEventAction;
        private Dictionary<<#=entry.name#>Event, Dictionary<Type, StateMachine<<#=stateType#>, <#=entry.name#>Event>.TriggerWithParameters>> _parameters =
            new Dictionary<<#=entry.name#>Event, Dictionary<Type, StateMachine<<#=stateType#>, <#=entry.name#>Event>.TriggerWithParameters>>();

        public <#=entry.name#>StateMachine(<#=entry.name#> <#=entry.settings.itemfieldname.Trim('_')#>, Func<<#=entry.name#>, <#=stateType#>> stateAccessor, Action<<#=entry.name#>, <#=stateType#>> stateMutator, Action<<#=entry.name#>FireBaseEvent> handleEventAction)
        {
            if (<#=entry.settings.itemfieldname.Trim('_')#> == null)
            {
                throw new ArgumentNullException(nameof(<#=entry.settings.itemfieldname.Trim('_')#>));
            }
            if (stateAccessor == null)
            {
                throw new ArgumentNullException(nameof(stateAccessor));
            }
            if (stateMutator == null)
            {
                throw new ArgumentNullException(nameof(stateMutator));
            }
            if (handleEventAction == null)
            {
                throw new ArgumentNullException(nameof(handleEventAction));
            }
            <#=entry.settings.itemfieldname#> = <#=entry.settings.itemfieldname.Trim('_')#>;
            _handleEventAction = handleEventAction;
            _sm = new StateMachine<<#=stateType#>, <#=entry.name#>Event>(() => stateAccessor(<#=entry.settings.itemfieldname#>), (val) => stateMutator(<#=entry.settings.itemfieldname#>, val));
            _sm.OnUnhandledTrigger(OnTransitionDeclined);
            _sm.OnTransitioned(OnTransitioned);
<#
        foreach (var state in transitionGroups.Where(o => !string.IsNullOrEmpty(o.ParameterType)).GroupBy(o => new { o.Event, o.ParameterType }))
        {
#>
            AddParameter(<#=entry.name#>Event.<#=state.Key.Event#>, typeof(<#=state.Key.ParameterType#>), _sm.SetTriggerParameters<<#=state.Key.ParameterType#>>(<#=entry.name#>Event.<#=state.Key.Event#>));
<#
        }
#>

<#
        foreach (var transitionGroup in entry.transitions.GroupBy(o => o.fromstate))
        {
            var fromState = transitionGroup.Key;
            foreach (var transition in transitionGroup.Where(o => o.@switch.@case.Any()))
            {
                var idx = 1;
                foreach (var c in transition.@switch.@case)
                {
#>
            Func<bool> predicate<#=transition.fromstate#><#=transition.@event#><#=idx#> = () => <#=c.when#>;
<#
                    idx++;
                }
            }
#>
            _sm.Configure(<#=entry.GetStateCode(fromState)#>)
<#
            foreach (var transition in transitionGroup)
            {
                if (transition.@switch.@case.Any())
                {
                    var def = transition.@switch.@default;
                    var idx = 1;

                    foreach (var c in transition.@switch.@case)
                    {
                        if (!string.IsNullOrEmpty(c.tostate))
                        {
#>
                .PermitIf(<#=entry.name #>Event.<#=transition.@event #>, <#=entry.GetStateCode(c.tostate) #>, predicate<#=transition.fromstate #><#=transition.@event #><#=idx #>, "<#=formatConditionFn(c.when)#>")
<#
                        }
                        else
                        {
#>
                .PermitReentryIf(<#=entry.name#>Event.<#=transition.@event#>, predicate<#=transition.fromstate#><#=transition.@event#><#=idx#>, "<#=formatConditionFn(c.when)#>")
<#
                        }
                        idx++;
                    }
                    if (def != null) //is default defined
                    {
                        idx = 1;
                        var predicate = "";
                        while (idx <= transition.@switch.@case.Count)
                        {
                            predicate += $"!predicate{transition.fromstate}{transition.@event}{idx}()";
                            if (idx < transition.@switch.@case.Count)
                            {
                                predicate += " && ";
                            }
                            idx++;
                        }
                        if (!string.IsNullOrEmpty(def.tostate) && def.tostate != transition.fromstate)
                        {
#>
                .PermitIf(<#=entry.name #>Event.<#=transition.@event #>, <#=entry.GetStateCode(def.tostate) #>, () => <#=predicate#>, "Otherwise")
<#
                        }
                        else
                        {
#>
                .PermitReentryIf(<#=entry.name #>Event.<#=transition.@event #>, () => <#=predicate#>, "Otherwise")
<#
                        }

                    }
                }
                else if (!string.IsNullOrEmpty(transition.tostate))
                {
#>
                .Permit(<#=entry.name #>Event.<#=transition.@event #>, <#=entry.GetStateCode(transition.tostate) #>)
<#
                }
                else
                {
#>
                .PermitReentry(<#=entry.name#>Event.<#=transition.@event#>)
<#
                }
            } // end foreach (var transition in transitionGroup)

            // We need to group by event in order to prevent having multiple OnEntryFrom for one event
            var previousTransitions = transitionGroups.Where(o => o.ToState == fromState || (o.FromState == fromState && string.IsNullOrEmpty(o.ToState)));
            foreach (var prevTransition in previousTransitions.GroupBy(o => new { o.Event }).Select(o => o.First()))
            {
                if (!string.IsNullOrEmpty(prevTransition.ParameterType))
                {
#>
                .OnEntryFrom(GetParameter<<#=prevTransition.ParameterType#>>(<#=entry.name#>Event.<#=prevTransition.Event#>), (p, t) => HandleEvent(t, p))
<#
                }
                else
                {
#>
                .OnEntryFrom(<#=entry.name#>Event.<#=prevTransition.Event#>, t => HandleEvent(t))
<#
                }
            }
#>
            ;

<#
        }
#>
        }

<#
        foreach (var g in transitionGroups.GroupBy(o => new {o.ParameterType}))
        {
#>
        private void HandleEvent(StateMachine<<#=stateType#>, <#=entry.name#>Event>.Transition transition<#=string.IsNullOrEmpty(g.Key.ParameterType) ? "" : $", {g.Key.ParameterType} param" #>)
        {
            if (transition.IsReentry)
            {
                switch (transition.Trigger)
                {
<#
            foreach (var evt in g.Where(o => o.Internal).Select(o => o.Event).Distinct())
            {
#>
                    case <#=entry.name#>Event.<#=evt#>:
                        _handleEventAction(new <#=entry.name#>Fire<#=evt#>ReentryEvent(transition.Source, <#=entry.settings.itemfieldname#><#=string.IsNullOrEmpty(g.Key.ParameterType) ? "" : ", param"#>));
                        break;
<#
            }
#>
                }
            }
            else
            {
                switch (transition.Trigger)
                {
<#
            foreach (var evt in g.Where(o => !o.Internal).Select(o => o.Event).Distinct())
            {
#>
                    case <#=entry.name#>Event.<#=evt#>:
                        _handleEventAction(new <#=entry.name#>Fire<#=evt#>Event(transition.Source, transition.Destination, <#=entry.settings.itemfieldname#><#=string.IsNullOrEmpty(g.Key.ParameterType) ? "" : ", param"#>));
                        break;
<#
            }
#>
                }
            }
        }

<#
        }

        foreach (var g in transitionGroups.GroupBy(o => new { o.Event, o.ParameterType}))
        {
#>
        public void Fire<#=g.Key.Event#>(<#=(string.IsNullOrEmpty(g.Key.ParameterType) ? "" : $"{g.Key.ParameterType} parameter")#>)
        {
<#
            if (!string.IsNullOrEmpty(g.Key.ParameterType))
            {
#>
            Fire(<#=entry.name#>Event.<#=g.Key.Event#>, parameter);
<#
            }
            else
            {
#>
            Fire(<#=entry.name#>Event.<#=g.Key.Event#>);
<#
            }
#>
        }

<#
        }
#>
        public bool CanFire(<#=entry.name#>Event evt)
        {
            return _sm.CanFire(evt);
        }

        public void Fire<T>(<#=entry.name#>Event evt, T parameter)
        {
            if (!CanFire(evt))
            {
                throw new ApplicationException($"Cannot fire event {evt} in the current state {_sm.State}");
            }
            var param = GetParameter<T>(evt);
            _sm.Fire(param, parameter);
        }

        public void Fire(<#=entry.name#>Event evt)
        {
            if (!CanFire(evt))
            {
                throw new ApplicationException($"Cannot fire event {evt} in the current state {_sm.State}");
            }
            _sm.Fire(evt);
        }

        private void AddParameter(<#=entry.name#>Event evt, Type paramType, StateMachine<<#=stateType#>, <#=entry.name#>Event>.TriggerWithParameters trigger)
        {
            Dictionary<Type, StateMachine<<#=stateType#>, <#=entry.name#>Event>.TriggerWithParameters> dict;
            if (!_parameters.TryGetValue(evt, out dict))
            {
                dict = new Dictionary<Type, StateMachine<<#=stateType#>, <#=entry.name#>Event>.TriggerWithParameters>();
                _parameters.Add(evt, dict);
            }
            dict[paramType] = trigger;
        }

        private StateMachine<<#=stateType#>, <#=entry.name#>Event>.TriggerWithParameters<T> GetParameter<T>(<#=entry.name#>Event evt)
        {
            Dictionary<Type, StateMachine<<#=stateType#>, <#=entry.name#>Event>.TriggerWithParameters> dict;
            if (!_parameters.TryGetValue(evt, out dict))
            {
                throw new KeyNotFoundException($"Key {evt} was not found in trigger parameters dictionary");
            }
            return (StateMachine<<#=stateType#>, <#=entry.name#>Event>.TriggerWithParameters<T>)dict[typeof(T)];
        }

        #region Transition events

        private void OnTransitioned(StateMachine<<#=stateType#>, <#=entry.name#>Event>.Transition t)
        {
            // TODO: EVENT - $"Transitioned from state '{t.Source}' to state '{t.Destination}' with event {t.Trigger}"
        }

        private void OnTransitionDeclined(<#=stateType#> state, <#=entry.name#>Event e)
        {
            // TODO: EVENT - $"Transitioned from state '{t.Source}' to state '{t.Destination}' with event {t.Trigger}"
            throw new ApplicationException($"Event '{e}' is not valid for state '{state}'");
        }

        #endregion


    }
}
<#
    }
    manager.EndBlock();
    manager.Process(true);
#>

<#+
    public partial class Entry
    {
        private static XmlSerializer serializer;

        private static XmlSerializer Serializer
        {
            get
            {
                if ((serializer == null))
                {
                    serializer = new XmlSerializer(typeof(Entry));
                }
                return serializer;
            }
        }
        
        #region Deserialize

        public static Entry Deserialize(string input)
        {
            StringReader stringReader = null;
            try
            {
                stringReader = new StringReader(input);
                return ((Entry)(Serializer.Deserialize(XmlReader.Create(stringReader))));
            }
            finally
            {
                if ((stringReader != null))
                {
                    stringReader.Dispose();
                }
            }
        }
        
        #endregion

        public IEnumerable<string> GetAllStates()
        {
            return transitions
                .Select(o => o.fromstate)
                .Union(transitions.Select(o => o.tostate))
                .Union(transitions.SelectMany(o => o.@switch.@default == null 
                    ? o.@switch.@case.Select(c => c.tostate) 
                    : o.@switch.@case.Select(c => c.tostate).Union(new List<string>{o.@switch.@default.tostate})))
                .Where(o => !string.IsNullOrEmpty(o))
                .Distinct();
        }

        public IEnumerable<TransitionGroup> GetTransitionGroups()
        {
            return transitions
                .SelectMany(o =>
                {
                    var list = new List<TransitionGroup>();
                    if (o.@switch.@case.Any())
                    {
                        list.AddRange(o.@switch.@case.Select(c => new TransitionGroup
                        {
                            Event = o.@event,
                            ParameterType = o.parametertype,
                            FromState = o.fromstate,
                            ToState = c.tostate,
                            Internal = string.IsNullOrEmpty(c.tostate)
                        }));
                        if(o.@switch.@default != null)
                            list.Add(new TransitionGroup
                            {
                                Event = o.@event,
                                ParameterType = o.parametertype,
                                FromState = o.fromstate,
                                ToState = o.@switch.@default.tostate,
                                Internal = string.IsNullOrEmpty(o.@switch.@default.tostate)
                            });
                    }
                    else
                    {
                        list.Add(new TransitionGroup
                        {
                            Event = o.@event,
                            ParameterType = o.parametertype,
                            FromState = o.fromstate,
                            ToState = o.tostate,
                            Internal = string.IsNullOrEmpty(o.tostate)
                        });
                    }
                    return list;
                });
        }

        public IEnumerable<string> GetAllEvents()
        {
            return transitions
                .Select(o => o.@event)
                .Where(o => !string.IsNullOrEmpty(o))
                .Distinct();
        }

        public string GetStateCode(string state)
        {
            return string.IsNullOrEmpty(settings.staticstateclass)
                ? @"" + state + ""
                : string.Format("{0}.{1}", settings.staticstateclass, state);
        }
    }

    public class TransitionGroup
    {
        public string ParameterType { get; set; }

        public string Event { get; set; }

        public string ToState { get; set; }

        public string FromState { get; set; }

        public bool Internal { get; set; }
    }

    public class XmlValidator
    {
        private readonly XmlSchemaSet _xmlSchemaSet;

        public XmlValidator()
        {
            _xmlSchemaSet = new XmlSchemaSet();
            var schema =XmlSchema.Read(new StringReader(Schema), SchemaValidationCallback);
            _xmlSchemaSet.Add(schema);
        }

        private void SchemaValidationCallback(object sender, ValidationEventArgs args)
        {
            switch (args.Severity)
            {
                case XmlSeverityType.Warning:
                    break;
                case XmlSeverityType.Error:
                    throw new XmlSchemaValidationException(args.Message);
            }
        }

        public void Validate(string xml, string fileName)
        {
            Validate(XDocument.Parse(xml), fileName);
        }

        public void Validate(XDocument xml, string fileName)
        {
            xml.Validate(_xmlSchemaSet, (sender, args) =>
            {
                switch (args.Severity)
                {
                    case XmlSeverityType.Warning:
                        break;
                    case XmlSeverityType.Error:
                        throw new XmlSchemaValidationException(string.Format("XML validation error for file {0}. Details: {1}", fileName, args.Exception));
                }
            });
        }
    }

#>

<#+

public const string Schema = @"<?xml version=""1.0"" encoding=""utf-8""?>
<xs:schema xmlns:xs=""http://www.w3.org/2001/XMLSchema"" elementFormDefault=""qualified"">
  
  <xs:complexType name=""Entry"">
    <xs:sequence>
      <xs:element name=""settings"" type=""Settings"" minOccurs=""0""/>
      <xs:element name=""transitions"">
        <xs:complexType>
          <xs:sequence>
            <xs:element name=""transition"" type=""Transition"" maxOccurs=""unbounded""/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name=""name"" type=""xs:string"" use=""required""/>
    <xs:attribute name=""namespace"" type=""xs:string"" use=""required""/>
  </xs:complexType>

  <xs:complexType name=""Transition"">
    <xs:sequence>
      <xs:element name=""switch"" type=""Switch"" minOccurs=""0""/>
    </xs:sequence>
    <xs:attribute name=""fromstate"" type=""xs:string"" use=""required""/>
    <xs:attribute name=""event"" type=""xs:string"" use=""required""/>
    <xs:attribute name=""tostate"" type=""xs:string"" use=""optional""/>
    <xs:attribute name=""parameter-type"" type=""xs:string"" use=""optional""/>
  </xs:complexType>
  
  <xs:complexType name=""Switch"">
    <xs:sequence>
      <xs:element name=""case"" maxOccurs=""unbounded"">
        <xs:complexType>
          <xs:attribute name=""when"" type=""xs:string"" use=""required""/>
          <xs:attribute name=""tostate"" type=""xs:string"" use=""optional""/>
        </xs:complexType>
      </xs:element>
      <xs:element name=""default"" minOccurs=""0"">
        <xs:complexType>
          <xs:attribute name=""tostate"" type=""xs:string"" use=""required""/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name=""Settings"">
    <xs:all>
      <xs:element name=""item-field-name"" type=""xs:string""/>
      <xs:element name=""async"" type=""xs:boolean"" minOccurs=""0""/>
      <xs:element name=""fire-event-base-type"" type=""xs:string"" minOccurs=""0""/>
      <xs:element name=""state-type"" type=""xs:string"" minOccurs=""0""/>
      <xs:element name=""static-state-class"" type=""xs:string"" minOccurs=""0""/>
      <xs:element name=""usings"" minOccurs=""0"">
        <xs:complexType>
          <xs:sequence>
            <xs:element name=""using"" type=""xs:string"" minOccurs=""0"" maxOccurs=""unbounded""/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:all>
  </xs:complexType>
  
  <xs:element name=""entry"" type=""Entry"" />
  
</xs:schema>
";

#>

<#+
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.6.1087.0")]
[Serializable]
[DesignerCategoryAttribute("code")]
[XmlRootAttribute("entry", Namespace = "", IsNullable = false)]
public partial class Entry
{

    public Settings settings { get; set; }
    [XmlArrayItemAttribute("transition", IsNullable = false)]
    public List<Transition> transitions { get; set; }
    [XmlAttribute]
    public string name { get; set; }
    [XmlAttribute]
    public string @namespace { get; set; }

    public Entry()
    {
        transitions = new List<Transition>();
        settings = new Settings();
    }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.6.1087.0")]
[Serializable]
[DesignerCategoryAttribute("code")]
public partial class Settings
{

    [XmlElementAttribute("item-field-name")]
    public string itemfieldname { get; set; }
    [XmlElementAttribute("async")]
    public bool async { get; set; }
    [XmlElementAttribute("fire-event-base-type")]
    public string fireeventbasetype { get; set; }
    [XmlElementAttribute("state-type")]
    public string statetype { get; set; }
    [XmlElementAttribute("static-state-class")]
    public string staticstateclass { get; set; }
    [XmlArrayItemAttribute("using", IsNullable = false)]
    public List<string> usings { get; set; }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.6.1087.0")]
[Serializable]
[DesignerCategoryAttribute("code")]
public partial class Switch
{

    [XmlElementAttribute("case")]
    public List<SwitchCase> @case { get; set; }
    public SwitchDefault @default { get; set; }

    public Switch()
    {
        @case = new List<SwitchCase>();
    }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.6.1087.0")]
[Serializable]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute(AnonymousType = true)]
public partial class SwitchCase
{

    [XmlAttribute]
    public string when { get; set; }
    [XmlAttribute]
    public string tostate { get; set; }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.6.1087.0")]
[Serializable]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute(AnonymousType = true)]
public partial class SwitchDefault
{

    [XmlAttribute]
    public string tostate { get; set; }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "4.6.1087.0")]
[Serializable]
[DesignerCategoryAttribute("code")]
public partial class Transition
{

    public Switch @switch { get; set; }
    [XmlAttribute]
    public string fromstate { get; set; }
    [XmlAttribute]
    public string @event { get; set; }
    [XmlAttribute]
    public string tostate { get; set; }
    [XmlAttributeAttribute("parameter-type")]
    public string parametertype { get; set; }

    public Transition()
    {
        @switch = new Switch();
    }
}
#>

<#+
/*
    Manager.tt from Damien Guard: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
*/


// Manager class records the various blocks so it can split them up
class Manager {
    private class Block {
        public String Name;
        public int Start, Length;
    }

    private Block currentBlock;
    private List<Block> files = new List<Block>();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List<String> generatedFileNames = new List<String>();

    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }

    public void KeepGeneratedFile(String name) {
        name = Path.Combine(Path.GetDirectoryName(host.TemplateFile), name);
        generatedFileNames.Add(name);
    }
    
    public void StartNewFile(String name) {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }

    public void StartFooter() {
        CurrentBlock = footer;
    }

    public void StartHeader() {
        CurrentBlock = header;
    }

    public void EndBlock() {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header && CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }

    public virtual void Process(bool split) {
        if (split) {
            EndBlock();
            var headerText = template.ToString(header.Start, header.Length);
            var footerText = template.ToString(footer.Start, footer.Length);
            var outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();
            foreach (var block in files) {
                String fileName = Path.Combine(outputPath, block.Name);
				if(File.Exists(fileName))
					File.SetLastWriteTime(fileName, DateTime.Now);
                String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
        }
    }

    public string GetAllContent()
    {
        var headerText = template.ToString(header.Start, header.Length);
        var footerText = template.ToString(footer.Start, footer.Length);
        var bodyText = string.Join(Environment.NewLine, files.Select(b=> template.ToString(b.Start, b.Length)));
        return headerText + bodyText + footerText;
    }

    protected virtual void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual String GetCustomToolNamespace(String fileName) {
        return null;
    }

    public virtual String DefaultProjectNamespace {
        get { return null; }
    }

    protected bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
        this.host = host;
        this.template = template;
    }

    private Block CurrentBlock {
        get { return currentBlock; }
        set {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }

    private class VSManager : Manager {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;

        public override String DefaultProjectNamespace {
            get {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override String GetCustomToolNamespace(string fileName) {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }

        public override void Process(bool split) {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.Process(split);
            projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }

        protected override void CreateFile(String fileName, String content) {
            if (IsFileContentDifferent(fileName, content)) {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) {
            var hostServiceProvider = (IServiceProvider)host;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
        }

        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
            var keepFileNameSet = new HashSet<String>(keepFileNames);
            var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);

            // Remove unused items from the project
            foreach (var pair in projectFiles)
                if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            // Add missing files to the project
            foreach (String fileName in keepFileNameSet)
                if (!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }

        private void CheckoutFileIfRequired(String fileName) {
            var sc = dte.SourceControl;
            if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
}

/*
    End of Manager.tt
*/
#>